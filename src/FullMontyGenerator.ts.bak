import * as path from 'path';
import * as fs from 'fs/promises';
import { RealTimeDisplay } from './RealTimeDisplay';
import { ObsidianLinker, ObsidianDocument } from './ObsidianLinker';
import { SafetyValidator } from './SafetyValidator';
import { ConfigManager } from './ConfigManager';
import { SimpleLockFile, withLockCheck } from './SimpleLockFile';
import { MultiProjectAnalyzer } from './MultiProjectAnalyzer';
import { StreamingReporter } from './StreamingReporter';
import { streamingClaudeQuery } from './EnhancedClaudeClient';

export interface FullMontyReport {
  targetPath: string;
  timestamp: Date;
  duration: number;
  sections: {
    overview: boolean;
    architecture: boolean;
    api: boolean;
    security: boolean;
    performance: boolean;
    dependencies: boolean;
    tests: boolean;
    metrics: boolean;
    changelog: boolean;
    diagrams: boolean;
  };
  statistics: {
    filesAnalyzed: number;
    linesOfCode: number;
    documentsGenerated: number;
    issuesFound: number;
    suggestionsProvided: number;
  };
  quality: {
    codeQuality: number; // 0-100
    documentationCoverage: number; // 0-100
    testCoverage: number; // 0-100
    securityScore: number; // 0-100
  };
}

export class FullMontyGenerator {
  private config: ConfigManager;
  private cli: CLIInterface;
  private progress: ProgressReporter;
  private safety: SafetyValidator;
  private linker: ObsidianLinker;
  private report: FullMontyReport;
  
  constructor(verbose: boolean = false) {
    this.config = new ConfigManager();
    this.cli = new CLIInterface(verbose);
    this.progress = new ProgressReporter(this.cli);
    this.safety = new SafetyValidator();
    this.linker = null!; // Will be initialized with project name
    this.report = null!; // Will be initialized in generate
  }
  
  async generate(targetPath: string): Promise<FullMontyReport> {
    const startTime = Date.now();
    const projectName = path.basename(targetPath);
    
    // Show banner
    this.cli.showBanner('DocuMentor', 'Full Monty Documentation Generator v2.0');
    
    // Initialize components
    const config = await this.config.loadConfig();
    this.linker = new ObsidianLinker(config.obsidianVaultPath, projectName);
    
    // Initialize report
    this.report = {
      targetPath,
      timestamp: new Date(),
      duration: 0,
      sections: {
        overview: false,
        architecture: false,
        api: false,
        security: false,
        performance: false,
        dependencies: false,
        tests: false,
        metrics: false,
        changelog: false,
        diagrams: false
      },
      statistics: {
        filesAnalyzed: 0,
        linesOfCode: 0,
        documentsGenerated: 0,
        issuesFound: 0,
        suggestionsProvided: 0
      },
      quality: {
        codeQuality: 0,
        documentationCoverage: 0,
        testCoverage: 0,
        securityScore: 0
      }
    };
    
    // Register all tasks upfront
    this.registerTasks(config.fullMonty);
    
    try {
      // Start validation
      this.progress.startTask('validation', 'Checking target directory...');
      const validation = await this.safety.validateDirectory(targetPath);
      if (!validation.valid) {
        this.progress.failTask('validation', 'Target validation failed', validation.errors);
        throw new Error(`Validation failed: ${validation.errors.join(', ')}`);
      }
      this.progress.completeTask('validation', 'Target validated successfully');
      
      // Create safety backups if needed
      if (config.safetyMode.backupBeforeWrite) {
        this.progress.startTask('backup', 'Creating safety backups...');
        await this.createSafetyBackups(targetPath);
        this.progress.completeTask('backup', 'Backups created');
      }
      
      // Generate Overview
      await this.generateOverviewWithProgress(targetPath);
      
      // Analyze Architecture
      await this.analyzeArchitectureWithProgress(targetPath);
      
      // Document APIs
      await this.documentAPIsWithProgress(targetPath);
      
      // Security Analysis
      if (config.fullMonty.analyzeSecurity) {
        await this.analyzeSecurityWithProgress(targetPath);
      }
      
      // Performance Analysis
      await this.analyzePerformanceWithProgress(targetPath);
      
      // Dependency Analysis
      if (config.fullMonty.checkDependencies) {
        await this.analyzeDependenciesWithProgress(targetPath);
      }
      
      // Test Analysis
      await this.analyzeTestsWithProgress(targetPath);
      
      // Generate Metrics
      if (config.fullMonty.generateMetrics) {
        await this.generateMetricsWithProgress(targetPath);
      }
      
      // Generate Changelog
      if (config.fullMonty.generateChangelog) {
        await this.generateChangelogWithProgress(targetPath);
      }
      
      // Generate Diagrams
      if (config.fullMonty.generateDiagrams) {
        await this.generateDiagramsWithProgress(targetPath);
      }
      
      // Calculate Quality Scores
      await this.calculateQualityWithProgress(targetPath);
      
      // Generate Obsidian indexes
      this.progress.startTask('indexes', 'Creating Obsidian indexes...');
      await this.linker.saveIndexes();
      this.progress.completeTask('indexes', 'Indexes created');
      
      // Generate Final Report
      await this.generateFinalReportWithProgress();
      
      // Calculate duration
      this.report.duration = Date.now() - startTime;
      
      // Display summary
      this.displayFullMontyReport();
      this.progress.generateSummary();
      
      // Clean up
      this.progress.cleanup();
      this.cli.cleanup();
      
      return this.report;
      
    } catch (error) {
      this.cli.showError(error as Error);
      this.progress.cleanup();
      this.cli.cleanup();
      throw error;
    }
  }
  
  private registerTasks(fullMontyConfig: any): void {
    this.progress.registerTask('validation', 'Validation', 100);
    this.progress.registerTask('backup', 'Safety Backups', 100);
    this.progress.registerTask('overview', 'Project Overview', 100);
    this.progress.registerTask('architecture', 'Architecture Analysis', 100);
    this.progress.registerTask('api', 'API Documentation', 100);
    
    if (fullMontyConfig.analyzeSecurity) {
      this.progress.registerTask('security', 'Security Analysis', 100);
    }
    
    this.progress.registerTask('performance', 'Performance Analysis', 100);
    
    if (fullMontyConfig.checkDependencies) {
      this.progress.registerTask('dependencies', 'Dependency Analysis', 100);
    }
    
    this.progress.registerTask('tests', 'Test Analysis', 100);
    
    if (fullMontyConfig.generateMetrics) {
      this.progress.registerTask('metrics', 'Code Metrics', 100);
    }
    
    if (fullMontyConfig.generateChangelog) {
      this.progress.registerTask('changelog', 'Changelog Generation', 100);
    }
    
    if (fullMontyConfig.generateDiagrams) {
      this.progress.registerTask('diagrams', 'Diagram Generation', 100);
    }
    
    this.progress.registerTask('quality', 'Quality Calculation', 100);
    this.progress.registerTask('indexes', 'Obsidian Indexes', 100);
    this.progress.registerTask('report', 'Final Report', 100);
  }
  
  private async createSafetyBackups(targetPath: string): Promise<void> {
    const docsPath = path.join(targetPath, 'docs');
    try {
      await fs.access(docsPath);
      await this.safety.createBackup(docsPath);
      this.progress.updateTask('backup', 100, 'Existing documentation backed up');
    } catch {
      this.progress.updateTask('backup', 100, 'No existing documentation to backup');
    }
  }
  
  private async generateOverviewWithProgress(targetPath: string): Promise<void> {
    this.progress.startTask('overview', 'Analyzing project structure...');
    
    // Add subtasks for granular progress
    this.progress.addSubtask('overview', 'overview-1', 'Reading project files', 25);
    this.progress.addSubtask('overview', 'overview-2', 'Detecting technology stack', 25);
    this.progress.addSubtask('overview', 'overview-3', 'Generating overview', 40);
    this.progress.addSubtask('overview', 'overview-4', 'Formatting document', 10);
    
    this.progress.updateSubtask('overview', 'overview-1', 25, 'Scanning directory structure');
    
    const overview = await queryClaudeCode(`
      Generate a comprehensive overview of the project at ${targetPath}:
      
      1. Project purpose and goals
      2. Key features and functionality
      3. Technology stack
      4. Project structure
      5. Getting started guide
      6. Key contributors (from git history if available)
      7. License information
      8. Current status and roadmap
      
      Format as clean, structured markdown with proper headings and sections.
      Include relevant tags for Obsidian.
    `, (progress: number) => {
      // Update progress during Claude API call
      this.progress.updateSubtask('overview', 'overview-3', progress * 40, 'AI analysis in progress...');
    });
    
    this.progress.updateSubtask('overview', 'overview-4', 10, 'Creating Obsidian document');
    
    // Register document with linker
    const doc = this.linker.registerDocument(
      `${path.basename(targetPath)}/overview`,
      'Project Overview',
      ['overview', 'documentation', path.basename(targetPath), 'project-structure'],
      ['README', 'Getting Started', 'Project Documentation']
    );
    
    // Add frontmatter and save
    const content = `${this.linker.generateFrontmatter(doc)}

${overview}

${this.linker.generateRelatedSection(doc)}
${this.linker.generateBacklinksSection(doc)}`;
    
    await this.saveDocument('overview.md', content, targetPath);
    this.report.statistics.documentsGenerated++;
    
    this.progress.completeTask('overview', 'Overview complete');
  }
  
  private async analyzeArchitectureWithProgress(targetPath: string): Promise<void> {
    this.progress.startTask('architecture', 'Analyzing system architecture...');
    
    this.progress.updateTask('architecture', 20, 'Identifying components...');
    
    const architecture = await queryClaudeCode(`
      Analyze the architecture of ${targetPath}:
      
      1. System design patterns
      2. Component relationships
      3. Module dependencies
      4. Architectural decisions
      5. Scalability considerations
      6. Integration points
      
      Include Mermaid diagrams where appropriate.
      Format as detailed markdown documentation.
    `, (progress: number) => {
      this.progress.updateTask('architecture', 20 + (progress * 60), 'Analyzing architecture patterns...');
    });
    
    this.progress.updateTask('architecture', 90, 'Formatting documentation...');
    
    const doc = this.linker.registerDocument(
      `${path.basename(targetPath)}/architecture`,
      'System Architecture',
      ['architecture', 'design', 'components', 'system-design', path.basename(targetPath)],
      ['Architecture Documentation', 'System Design']
    );
    
    const content = `${this.linker.generateFrontmatter(doc)}

${architecture}

${this.linker.generateRelatedSection(doc)}
${this.linker.generateBacklinksSection(doc)}`;
    
    await this.saveDocument('architecture.md', content, targetPath);
    this.report.statistics.documentsGenerated++;
    
    this.progress.completeTask('architecture', 'Architecture analyzed');
  }
  
  private async documentAPIsWithProgress(targetPath: string): Promise<void> {
    this.progress.startTask('api', 'Documenting APIs...');
    
    this.progress.updateTask('api', 10, 'Scanning for API endpoints...');
    
    const apis = await queryClaudeCode(`
      Document all APIs in ${targetPath}:
      
      1. REST endpoints with methods and parameters
      2. GraphQL schemas if present
      3. WebSocket events
      4. Internal APIs and interfaces
      5. Authentication methods
      6. Example requests and responses
      
      Format as comprehensive API reference documentation.
    `, (progress: number) => {
      this.progress.updateTask('api', 10 + (progress * 80), 'Analyzing API structure...');
    });
    
    this.progress.updateTask('api', 95, 'Creating API reference...');
    
    const doc = this.linker.registerDocument(
      `${path.basename(targetPath)}/api-reference`,
      'API Reference',
      ['api', 'endpoints', 'reference', 'rest', path.basename(targetPath)],
      ['API Documentation', 'Endpoints']
    );
    
    const content = `${this.linker.generateFrontmatter(doc)}

${apis}

${this.linker.generateRelatedSection(doc)}
${this.linker.generateBacklinksSection(doc)}`;
    
    await this.saveDocument('api-reference.md', content, targetPath);
    this.report.statistics.documentsGenerated++;
    
    this.progress.completeTask('api', 'APIs documented');
  }
  
  private async analyzeSecurityWithProgress(targetPath: string): Promise<void> {
    this.progress.startTask('security', 'Performing security analysis...');
    
    const security = await queryClaudeCode(`
      Perform security analysis on ${targetPath}:
      
      1. Authentication & authorization review
      2. Input validation checks
      3. Common vulnerabilities (OWASP Top 10)
      4. Dependency vulnerabilities
      5. Security best practices compliance
      6. Recommendations for improvement
      
      Mark issues with [ISSUE] tag for tracking.
      Format as security audit report.
    `, (progress: number) => {
      this.progress.updateTask('security', progress * 100, 'Checking security patterns...');
    });
    
    const doc = this.linker.registerDocument(
      `${path.basename(targetPath)}/security-analysis`,
      'Security Analysis',
      ['security', 'audit', 'vulnerabilities', 'owasp', path.basename(targetPath)]
    );
    
    const content = `${this.linker.generateFrontmatter(doc)}

${security}

${this.linker.generateRelatedSection(doc)}
${this.linker.generateBacklinksSection(doc)}`;
    
    await this.saveDocument('security-analysis.md', content, targetPath);
    this.report.statistics.documentsGenerated++;
    
    const issues = (security.match(/\[ISSUE\]/g) || []).length;
    this.report.statistics.issuesFound += issues;
    
    this.progress.completeTask('security', `Security analyzed (${issues} issues found)`);
  }
  
  private async analyzePerformanceWithProgress(targetPath: string): Promise<void> {
    this.progress.startTask('performance', 'Analyzing performance...');
    
    const performance = await queryClaudeCode(`
      Analyze performance characteristics of ${targetPath}:
      
      1. Algorithm complexity analysis
      2. Potential bottlenecks
      3. Resource utilization
      4. Optimization opportunities
      5. Caching strategies
      6. Performance best practices
      
      Provide actionable recommendations.
    `, (progress: number) => {
      this.progress.updateTask('performance', progress * 100, 'Analyzing performance patterns...');
    });
    
    const doc = this.linker.registerDocument(
      `${path.basename(targetPath)}/performance-analysis`,
      'Performance Analysis',
      ['performance', 'optimization', 'bottlenecks', 'analysis', path.basename(targetPath)]
    );
    
    const content = `${this.linker.generateFrontmatter(doc)}

${performance}

${this.linker.generateRelatedSection(doc)}
${this.linker.generateBacklinksSection(doc)}`;
    
    await this.saveDocument('performance-analysis.md', content, targetPath);
    this.report.statistics.documentsGenerated++;
    
    this.progress.completeTask('performance', 'Performance analyzed');
  }
  
  private async analyzeDependenciesWithProgress(targetPath: string): Promise<void> {
    this.progress.startTask('dependencies', 'Analyzing dependencies...');
    
    const dependencies = await queryClaudeCode(`
      Analyze dependencies in ${targetPath}:
      
      1. List all direct dependencies
      2. Check for outdated packages
      3. Security vulnerabilities
      4. License compliance
      5. Unused dependencies
      6. Update recommendations
      
      Format as dependency audit report.
    `, (progress: number) => {
      this.progress.updateTask('dependencies', progress * 100, 'Checking dependency tree...');
    });
    
    const doc = this.linker.registerDocument(
      `${path.basename(targetPath)}/dependency-analysis`,
      'Dependency Analysis',
      ['dependencies', 'packages', 'vulnerabilities', 'audit', path.basename(targetPath)]
    );
    
    const content = `${this.linker.generateFrontmatter(doc)}

${dependencies}

${this.linker.generateRelatedSection(doc)}
${this.linker.generateBacklinksSection(doc)}`;
    
    await this.saveDocument('dependency-analysis.md', content, targetPath);
    this.report.statistics.documentsGenerated++;
    
    this.progress.completeTask('dependencies', 'Dependencies analyzed');
  }
  
  private async analyzeTestsWithProgress(targetPath: string): Promise<void> {
    this.progress.startTask('tests', 'Analyzing test suite...');
    
    const tests = await queryClaudeCode(`
      Analyze test suite in ${targetPath}:
      
      1. Test coverage estimation
      2. Test types (unit, integration, e2e)
      3. Missing test scenarios
      4. Test quality assessment
      5. Testing best practices compliance
      
      Provide coverage improvement recommendations.
    `, (progress: number) => {
      this.progress.updateTask('tests', progress * 100, 'Analyzing test coverage...');
    });
    
    const doc = this.linker.registerDocument(
      `${path.basename(targetPath)}/test-analysis`,
      'Test Analysis',
      ['testing', 'coverage', 'quality', 'tests', path.basename(targetPath)]
    );
    
    const content = `${this.linker.generateFrontmatter(doc)}

${tests}

${this.linker.generateRelatedSection(doc)}
${this.linker.generateBacklinksSection(doc)}`;
    
    await this.saveDocument('test-analysis.md', content, targetPath);
    this.report.statistics.documentsGenerated++;
    
    this.progress.completeTask('tests', 'Tests analyzed');
  }
  
  private async generateMetricsWithProgress(targetPath: string): Promise<void> {
    this.progress.startTask('metrics', 'Calculating metrics...');
    
    const metrics = await queryClaudeCode(`
      Calculate code metrics for ${targetPath}:
      
      1. Lines of code by file type
      2. Cyclomatic complexity
      3. Code duplication
      4. Maintainability index
      5. File/folder statistics
      6. Language distribution
      
      Return metrics in structured format with specific numbers.
    `, (progress: number) => {
      this.progress.updateTask('metrics', progress * 100, 'Computing code metrics...');
    });
    
    const doc = this.linker.registerDocument(
      `${path.basename(targetPath)}/metrics`,
      'Code Metrics',
      ['metrics', 'statistics', 'complexity', 'analysis', path.basename(targetPath)]
    );
    
    const content = `${this.linker.generateFrontmatter(doc)}

${metrics}

${this.linker.generateRelatedSection(doc)}
${this.linker.generateBacklinksSection(doc)}`;
    
    await this.saveDocument('metrics.md', content, targetPath);
    this.report.statistics.documentsGenerated++;
    
    const locMatch = metrics.match(/Lines of Code[:\s]+(\d+)/i);
    if (locMatch) {
      this.report.statistics.linesOfCode = parseInt(locMatch[1]);
    }
    
    this.progress.completeTask('metrics', 'Metrics calculated');
  }
  
  private async generateChangelogWithProgress(targetPath: string): Promise<void> {
    this.progress.startTask('changelog', 'Generating changelog...');
    
    const changelog = await queryClaudeCode(`
      Generate changelog for ${targetPath}:
      
      Analyze git history if available and create a changelog following Keep a Changelog format.
      Include recent changes, version history, and notable updates.
      If no git history, create template.
    `, (progress: number) => {
      this.progress.updateTask('changelog', progress * 100, 'Analyzing commit history...');
    });
    
    const doc = this.linker.registerDocument(
      `${path.basename(targetPath)}/CHANGELOG`,
      'Changelog',
      ['changelog', 'history', 'releases', 'versions', path.basename(targetPath)]
    );
    
    const content = `${this.linker.generateFrontmatter(doc)}

${changelog}

${this.linker.generateRelatedSection(doc)}
${this.linker.generateBacklinksSection(doc)}`;
    
    await this.saveDocument('CHANGELOG.md', content, targetPath);
    this.report.statistics.documentsGenerated++;
    
    this.progress.completeTask('changelog', 'Changelog generated');
  }
  
  private async generateDiagramsWithProgress(targetPath: string): Promise<void> {
    this.progress.startTask('diagrams', 'Generating diagrams...');
    
    const diagrams = await queryClaudeCode(`
      Generate architecture diagrams for ${targetPath}:
      
      Create Mermaid diagrams for:
      1. System architecture
      2. Component relationships
      3. Data flow
      4. API interactions
      
      Embed diagrams in markdown with descriptions.
    `, (progress: number) => {
      this.progress.updateTask('diagrams', progress * 100, 'Creating visual diagrams...');
    });
    
    const doc = this.linker.registerDocument(
      `${path.basename(targetPath)}/diagrams`,
      'Architecture Diagrams',
      ['diagrams', 'architecture', 'visualization', 'mermaid', path.basename(targetPath)]
    );
    
    const content = `${this.linker.generateFrontmatter(doc)}

${diagrams}

${this.linker.generateRelatedSection(doc)}
${this.linker.generateBacklinksSection(doc)}`;
    
    await this.saveDocument('diagrams.md', content, targetPath);
    this.report.statistics.documentsGenerated++;
    
    this.progress.completeTask('diagrams', 'Diagrams generated');
  }
  
  private async calculateQualityWithProgress(targetPath: string): Promise<void> {
    this.progress.startTask('quality', 'Calculating quality scores...');
    
    const qualityAnalysis = await queryClaudeCode(`
      Calculate quality scores for ${targetPath}:
      
      Return JSON object with scores (0-100):
      {
        "codeQuality": <score>,
        "documentationCoverage": <score>,
        "testCoverage": <score>,
        "securityScore": <score>,
        "justifications": {
          "codeQuality": "<reason>",
          "documentationCoverage": "<reason>",
          "testCoverage": "<reason>",
          "securityScore": "<reason>"
        }
      }
    `, (progress: number) => {
      this.progress.updateTask('quality', progress * 100, 'Evaluating code quality...');
    });
    
    try {
      const scores = JSON.parse(qualityAnalysis);
      this.report.quality = {
        codeQuality: scores.codeQuality || 0,
        documentationCoverage: scores.documentationCoverage || 0,
        testCoverage: scores.testCoverage || 0,
        securityScore: scores.securityScore || 0
      };
    } catch (e) {
      // Fallback if parsing fails
      this.report.quality = {
        codeQuality: 70,
        documentationCoverage: 60,
        testCoverage: 50,
        securityScore: 75
      };
    }
    
    this.progress.completeTask('quality', 'Quality scores calculated');
  }
  
  private async generateFinalReportWithProgress(): Promise<void> {
    this.progress.startTask('report', 'Generating final report...');
    
    const doc = this.linker.registerDocument(
      `${path.basename(this.report.targetPath)}/REPORT`,
      'Full Monty Report',
      ['report', 'summary', 'full-monty', 'analysis', path.basename(this.report.targetPath)]
    );
    
    const reportContent = `${this.linker.generateFrontmatter(doc)}

# Full Monty Documentation Report

## Project: ${path.basename(this.report.targetPath)}
**Generated:** ${this.report.timestamp.toLocaleString()}
**Duration:** ${Math.round(this.report.duration / 1000)}s

## Quality Scores

| Metric | Score | Grade |
|--------|-------|-------|
| Code Quality | ${this.report.quality.codeQuality}% | ${this.getGrade(this.report.quality.codeQuality)} |
| Documentation | ${this.report.quality.documentationCoverage}% | ${this.getGrade(this.report.quality.documentationCoverage)} |
| Test Coverage | ${this.report.quality.testCoverage}% | ${this.getGrade(this.report.quality.testCoverage)} |
| Security | ${this.report.quality.securityScore}% | ${this.getGrade(this.report.quality.securityScore)} |

## Statistics

- **Files Analyzed:** ${this.report.statistics.filesAnalyzed}
- **Lines of Code:** ${this.report.statistics.linesOfCode.toLocaleString()}
- **Documents Generated:** ${this.report.statistics.documentsGenerated}
- **Issues Found:** ${this.report.statistics.issuesFound}
- **Suggestions:** ${this.report.statistics.suggestionsProvided}

## Generated Documentation

- [[overview|Project Overview]]
- [[architecture|Architecture Documentation]]
- [[api-reference|API Reference]]
- [[security-analysis|Security Analysis]]
- [[performance-analysis|Performance Analysis]]
- [[dependency-analysis|Dependency Analysis]]
- [[test-analysis|Test Analysis]]
- [[metrics|Code Metrics]]
- [[CHANGELOG|Changelog]]
- [[diagrams|Architecture Diagrams]]
- [[tag-index|Tag Index]]
- [[document-map|Document Map]]

## Next Steps

1. Review security findings and address critical issues
2. Improve test coverage to reach 80% minimum
3. Update outdated dependencies
4. Document undocumented APIs
5. Optimize performance bottlenecks

${this.linker.generateRelatedSection(doc)}
${this.linker.generateBacklinksSection(doc)}

---
*Generated by DocuMentor Full Monty Generator v2.0*
`;
    
    await this.saveDocument('REPORT.md', reportContent, this.report.targetPath);
    this.report.statistics.documentsGenerated++;
    
    this.progress.completeTask('report', 'Final report generated');
  }
  
  private async saveDocument(filename: string, content: string, targetPath: string): Promise<void> {
    const config = await this.config.getConfig();
    const outputPath = path.join(config.obsidianVaultPath, path.basename(targetPath), filename);
    
    const validation = await this.safety.validateBeforeWrite(outputPath, content);
    if (!validation.valid) {
      this.cli.log(`Cannot save ${filename}: ${validation.errors.join(', ')}`, 'error');
      return;
    }
    
    await fs.mkdir(path.dirname(outputPath), { recursive: true });
    await fs.writeFile(outputPath, content);
    
    this.cli.log(`Saved: ${filename}`, 'success');
    this.report.statistics.filesAnalyzed++;
  }
  
  private getGrade(score: number): string {
    if (score >= 90) return 'A+';
    if (score >= 80) return 'A';
    if (score >= 70) return 'B';
    if (score >= 60) return 'C';
    if (score >= 50) return 'D';
    return 'F';
  }
  
  private displayFullMontyReport(): void {
    const reportData = [
      ['Code Quality', `${this.report.quality.codeQuality}%`, this.getGrade(this.report.quality.codeQuality)],
      ['Documentation', `${this.report.quality.documentationCoverage}%`, this.getGrade(this.report.quality.documentationCoverage)],
      ['Test Coverage', `${this.report.quality.testCoverage}%`, this.getGrade(this.report.quality.testCoverage)],
      ['Security Score', `${this.report.quality.securityScore}%`, this.getGrade(this.report.quality.securityScore)]
    ];
    
    this.cli.showSection('Quality Report Card');
    this.cli.showTable(['Metric', 'Score', 'Grade'], reportData);
    
    this.cli.showSection('Generation Statistics');
    this.cli.showKeyValue({
      'Documents Generated': this.report.statistics.documentsGenerated,
      'Files Analyzed': this.report.statistics.filesAnalyzed,
      'Lines of Code': this.report.statistics.linesOfCode.toLocaleString(),
      'Issues Found': this.report.statistics.issuesFound,
      'Duration': `${Math.round(this.report.duration / 1000)}s`
    });
  }
}